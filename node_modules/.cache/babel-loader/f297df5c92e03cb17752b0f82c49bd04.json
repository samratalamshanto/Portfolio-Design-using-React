{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar expand = require('./lib/expand');\n\nvar utils = require('./lib/utils');\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length,\n      i = 0;\n  var omit = [],\n      keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33\n    /* ! */\n    ) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n\n  return utils.diff(keep, omit);\n}\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n\n    if (negate) {\n      pattern = pattern.slice(1);\n    } // we need to remove the character regardless,\n    // so the above logic is still needed\n\n\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n\n  var len = files.length,\n      i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) {\n      continue;\n    }\n\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  } // if `negate` was defined, diff negated files\n\n\n  if (negate) {\n    res = utils.diff(files, res);\n  } // if `ignore` was defined, diff ignored filed\n\n\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n\n  return res;\n}\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length,\n      i = 0;\n  var patternMatchers = Array(len);\n\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function (fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length,\n        i = 0;\n    var res = true;\n    fp = utils.unixify(fp, opts);\n\n    while (i < len) {\n      var fn = patternMatchers[i++];\n\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n\n    return res;\n  };\n}\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = pattern !== '';\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n  fp = utils.unixify(fp, opts);\n\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n}\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  } // pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return function (fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  } // strings, all the way down...\n\n\n  pattern = utils.unixify(pattern, opts); // pattern is a non-glob string\n\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  } // pattern is a glob string\n\n\n  var re = makeRe(pattern, opts); // `matchBase` is defined\n\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  } // `matchBase` is not defined\n\n\n  return function (fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts); // pass in tokens to avoid parsing more than once\n\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  } // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n\n\n  return /$^/;\n}\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\n\nfunction wrapGlob(glob, opts) {\n  var prefix = opts && !opts.contains ? '^' : '';\n  var after = opts && !opts.contains ? '$' : '';\n  glob = '(?:' + glob + ')' + after;\n\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n\n  return prefix + glob;\n}\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n\n  return utils.cache(toRegex, glob, opts);\n}\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\n\n\nmicromatch.any = any;\nmicromatch.braces = micromatch.braceExpand = utils.braces;\nmicromatch.contains = contains;\nmicromatch.expand = expand;\nmicromatch.filter = filter;\nmicromatch.isMatch = isMatch;\nmicromatch.makeRe = makeRe;\nmicromatch.match = match;\nmicromatch.matcher = matcher;\nmicromatch.matchKeys = matchKeys;\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;","map":{"version":3,"names":["expand","require","utils","micromatch","files","patterns","opts","cache","Array","isArray","match","len","length","i","omit","keep","glob","charCodeAt","push","apply","slice","diff","pattern","typeOf","Error","msg","arrayify","negate","orig","charAt","nonegate","_isMatch","matcher","res","file","fp","unixify","failglob","nonull","nullglob","unescapeGlob","ignore","nodupes","unique","filter","TypeError","patternMatchers","fn","isMatch","contains","isGlob","indexOf","any","matchKeys","obj","options","key","hasOwnProperty","RegExp","test","matchPath","re","makeRe","matchBase","hasFilename","toRegex","Object","create","flags","nocase","parsed","negated","wrapGlob","err","reason","strict","SyntaxError","prefix","after","method","what","type","braces","braceExpand","module","exports"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/glob-stream/node_modules/micromatch/index.js"],"sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length, i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function(fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length, i = 0;\n    var res = true;\n\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = (pattern !== '');\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any       = any;\nmicromatch.braces    = micromatch.braceExpand = utils.braces;\nmicromatch.contains  = contains;\nmicromatch.expand    = expand;\nmicromatch.filter    = filter;\nmicromatch.isMatch   = isMatch;\nmicromatch.makeRe    = makeRe;\nmicromatch.match     = match;\nmicromatch.matcher   = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}