{"ast":null,"code":"// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar util = require('core-util-is');\n\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream;\n\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.\n\n  this.highWaterMark = ~~this.highWaterMark;\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // count buffered requests\n\n  this.bufferedRequestCount = 0; // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n  this._writableState = new WritableState(options, this); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n  stream.emit('error', er);\n  processNextTick(cb, er);\n} // If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  return chunk;\n} // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\n\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}","map":{"version":3,"names":["module","exports","Writable","processNextTick","require","asyncWrite","process","browser","indexOf","version","slice","setImmediate","Buffer","WritableState","util","inherits","internalUtil","deprecate","Stream","_","EventEmitter","nop","WriteReq","chunk","encoding","cb","callback","next","Duplex","options","stream","objectMode","writableObjectMode","hwm","highWaterMark","defaultHwm","needDrain","ending","ended","finished","noDecode","decodeStrings","defaultEncoding","length","writing","corked","sync","bufferProcessing","onwrite","er","writecb","writelen","bufferedRequest","lastBufferedRequest","pendingcb","prefinished","errorEmitted","bufferedRequestCount","corkedRequestsFree","CorkedRequest","prototype","getBuffer","writableStateGetBuffer","current","out","push","Object","defineProperty","get","_writableState","writable","write","_write","writev","_writev","call","pipe","emit","Error","writeAfterEnd","validChunk","state","valid","isBuffer","undefined","TypeError","ret","writeOrBuffer","cork","uncork","clearBuffer","setDefaultEncoding","toLowerCase","decodeChunk","len","last","doWrite","onwriteError","onwriteStateUpdate","needFinish","afterWrite","onwriteDrain","finishMaybe","entry","l","buffer","Array","holder","count","finish","end","endWritable","prefinish","need","once","_this","err"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/concat-stream/node_modules/readable-stream/lib/_stream_writable.js"],"sourcesContent":["// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}