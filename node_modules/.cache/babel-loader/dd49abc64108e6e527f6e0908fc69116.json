{"ast":null,"code":"'use strict';\n\nvar utils = require('../utils');\n\nvar PLUGIN_NAME = utils.PLUGIN_NAME;\n\nvar makeDebug = require('debug-fabulous')();\n\nvar convert = require('convert-source-map');\n\nvar stripBom = require('strip-bom');\n\nvar urlRegex = utils.urlRegex;\n\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar unixStylePath = utils.unixStylePath;\n\nmodule.exports = function (options, file, fileContent) {\n  function loadMaps() {\n    var sources = {\n      path: '',\n      map: null,\n      content: fileContent,\n      preExistingComment: null\n    };\n\n    _getInlineSources(sources);\n\n    if (!sources.map) // ahh not inline, so try file\n      _getFileSources(sources);\n\n    _fixSources(sources);\n\n    return sources;\n  }\n\n  function _fixSources(sources) {\n    var debug = makeDebug(PLUGIN_NAME + ':init:internals:loadMaps:_fixSources'); // fix source paths and sourceContent for imported source map\n\n    if (sources.map) {\n      sources.map.sourcesContent = sources.map.sourcesContent || [];\n      sources.map.sources.forEach(function (source, i) {\n        if (source.match(urlRegex)) {\n          sources.map.sourcesContent[i] = sources.map.sourcesContent[i] || null;\n          return;\n        }\n\n        var absPath = path.resolve(sources.path, source);\n        sources.map.sources[i] = unixStylePath(path.relative(file.base, absPath));\n\n        if (!sources.map.sourcesContent[i]) {\n          var sourceContent = null;\n\n          if (sources.map.sourceRoot) {\n            if (sources.map.sourceRoot.match(urlRegex)) {\n              sources.map.sourcesContent[i] = null;\n              return;\n            }\n\n            absPath = path.resolve(sources.path, sources.map.sourceRoot, source);\n          } // if current file: use content\n\n\n          if (absPath === file.path) {\n            sourceContent = sources.content;\n          } else {\n            //attempt load content from file\n            try {\n              debug(utils.logCb('No source content for \"' + source + '\". Loading from file.'));\n              sourceContent = stripBom(fs.readFileSync(absPath, 'utf8'));\n            } catch (e) {\n              debug(utils.logCb('warn: source file not found: ' + absPath));\n            }\n          }\n\n          sources.map.sourcesContent[i] = sourceContent;\n        }\n      }); // remove source map comment from source\n\n      file.contents = new Buffer(sources.content, 'utf8');\n    }\n  }\n\n  function _getInlineSources(sources) {\n    var debug = makeDebug(PLUGIN_NAME + ':init:internals:loadMaps:_getInlineSources');\n    sources.preExistingComment = utils.getInlinePreExisting(sources.content); // Try to read inline source map\n\n    sources.map = convert.fromSource(sources.content, options.largeFile);\n    if (!sources.map) return sources;\n    sources.map = sources.map.toObject(); // sources in map are relative to the source file\n\n    sources.path = path.dirname(file.path);\n\n    if (!options.largeFile) {\n      debug('comment REMOVED');\n      sources.content = convert.removeComments(sources.content);\n    }\n  }\n\n  function _getFileSources(sources) {\n    // look for source map comment referencing a source map file\n    var mapComment = convert.mapFileCommentRegex.exec(sources.content);\n    var mapFile;\n\n    if (mapComment) {\n      sources.preExistingComment = mapComment[1] || mapComment[2];\n      mapFile = path.resolve(path.dirname(file.path), sources.preExistingComment);\n      sources.content = convert.removeMapFileComments(sources.content); // if no comment try map file with same name as source file\n    } else {\n      mapFile = file.path + '.map';\n    } // sources in external map are relative to map file\n\n\n    sources.path = path.dirname(mapFile);\n\n    try {\n      sources.map = JSON.parse(stripBom(fs.readFileSync(mapFile, 'utf8')));\n    } catch (e) {} //should we really swallow this error?\n\n  }\n\n  return {\n    loadMaps: loadMaps\n  };\n};","map":{"version":3,"names":["utils","require","PLUGIN_NAME","makeDebug","convert","stripBom","urlRegex","fs","path","unixStylePath","module","exports","options","file","fileContent","loadMaps","sources","map","content","preExistingComment","_getInlineSources","_getFileSources","_fixSources","debug","sourcesContent","forEach","source","i","match","absPath","resolve","relative","base","sourceContent","sourceRoot","logCb","readFileSync","e","contents","Buffer","getInlinePreExisting","fromSource","largeFile","toObject","dirname","removeComments","mapComment","mapFileCommentRegex","exec","mapFile","removeMapFileComments","JSON","parse"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/gulp-sourcemaps/src/init/index.internals.js"],"sourcesContent":["'use strict';\n\nvar utils = require('../utils');\nvar PLUGIN_NAME = utils.PLUGIN_NAME;\nvar makeDebug = require('debug-fabulous')();\nvar convert = require('convert-source-map');\nvar stripBom = require('strip-bom');\nvar urlRegex = utils.urlRegex;\nvar fs = require('graceful-fs');\nvar path = require('path');\nvar unixStylePath = utils.unixStylePath;\n\nmodule.exports = function(options, file, fileContent) {\n\n  function loadMaps() {\n\n    var sources = {\n      path: '',\n      map: null,\n      content: fileContent,\n      preExistingComment: null\n    };\n\n    _getInlineSources(sources);\n    if (!sources.map) // ahh not inline, so try file\n      _getFileSources(sources);\n\n    _fixSources(sources);\n\n    return sources;\n  }\n\n  function _fixSources(sources) {\n    var debug = makeDebug(PLUGIN_NAME + ':init:internals:loadMaps:_fixSources');\n\n    // fix source paths and sourceContent for imported source map\n    if (sources.map) {\n      sources.map.sourcesContent = sources.map.sourcesContent || [];\n      sources.map.sources.forEach(function(source, i) {\n        if (source.match(urlRegex)) {\n          sources.map.sourcesContent[i] = sources.map.sourcesContent[i] || null;\n          return;\n        }\n        var absPath = path.resolve(sources.path, source);\n        sources.map.sources[i] = unixStylePath(path.relative(file.base, absPath));\n\n        if (!sources.map.sourcesContent[i]) {\n          var sourceContent = null;\n          if (sources.map.sourceRoot) {\n            if (sources.map.sourceRoot.match(urlRegex)) {\n              sources.map.sourcesContent[i] = null;\n              return;\n            }\n            absPath = path.resolve(sources.path, sources.map.sourceRoot, source);\n          }\n\n          // if current file: use content\n          if (absPath === file.path) {\n            sourceContent = sources.content;\n          } else { //attempt load content from file\n            try {\n              debug(utils.logCb('No source content for \"' + source + '\". Loading from file.'));\n              sourceContent = stripBom(fs.readFileSync(absPath, 'utf8'));\n            } catch (e) {\n              debug(utils.logCb('warn: source file not found: ' + absPath));\n            }\n          }\n          sources.map.sourcesContent[i] = sourceContent;\n        }\n\n      });\n      // remove source map comment from source\n      file.contents = new Buffer(sources.content, 'utf8');\n    }\n\n  }\n\n  function _getInlineSources(sources) {\n    var debug = makeDebug(PLUGIN_NAME + ':init:internals:loadMaps:_getInlineSources');\n\n    sources.preExistingComment = utils.getInlinePreExisting(sources.content);\n    // Try to read inline source map\n    sources.map = convert.fromSource(sources.content, options.largeFile);\n\n    if (!sources.map)\n      return sources;\n\n    sources.map = sources.map.toObject();\n    // sources in map are relative to the source file\n    sources.path = path.dirname(file.path);\n    if (!options.largeFile) {\n      debug('comment REMOVED');\n      sources.content = convert.removeComments(sources.content);\n    }\n  }\n\n  function _getFileSources(sources) {\n    // look for source map comment referencing a source map file\n    var mapComment = convert.mapFileCommentRegex.exec(sources.content);\n\n    var mapFile;\n    if (mapComment) {\n      sources.preExistingComment = mapComment[1] || mapComment[2];\n      mapFile = path.resolve(path.dirname(file.path), sources.preExistingComment);\n      sources.content = convert.removeMapFileComments(sources.content);\n      // if no comment try map file with same name as source file\n    } else {\n      mapFile = file.path + '.map';\n    }\n\n    // sources in external map are relative to map file\n    sources.path = path.dirname(mapFile);\n\n    try {\n      sources.map = JSON.parse(stripBom(fs.readFileSync(mapFile, 'utf8')));\n    } catch (e) {} //should we really swallow this error?\n  }\n\n  return {\n    loadMaps: loadMaps\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}