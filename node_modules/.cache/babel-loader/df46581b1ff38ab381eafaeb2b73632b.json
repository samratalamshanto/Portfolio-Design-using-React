{"ast":null,"code":"/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\n\nvar re,\n    cache = {};\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {},\n      i = 0; // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!('); // support file extension negation\n\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n\n    return escape('[^.]+');\n  }); // create a unique key for caching by\n  // combining the string and options\n\n  var key = str + String(!!opts.regex) + String(!!opts.contains) + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + i++ + '__'; // use the prefix of the _last_ (outtermost) pattern\n\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length; // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex ? toRegex(str, opts.contains, opts.negate) : str;\n  result = result.split('.').join('\\\\.'); // cache the result and return it\n\n  return cache[key] = result;\n}\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n\n    case '@':\n      return '(?:' + inner + ')';\n\n    case '+':\n      return '(?:' + inner + ')+';\n\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*');\n\n    case '?':\n      return '(?:' + inner + '|)';\n\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n/**\n * extglob regex.\n */\n\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n/**\n * Negation regex\n */\n\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = '(?:' + pattern + ')' + after;\n\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n\n  return new RegExp(prefix + pattern);\n}","map":{"version":3,"names":["isExtglob","require","re","cache","module","exports","extglob","str","opts","o","i","replace","m","ch","escape","key","String","regex","contains","hasOwnProperty","RegExp","negate","exec","prefix","inner","id","wrap","split","join","keys","Object","len","length","prop","result","toRegex","esc","pattern","isNegated","after"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/extglob/index.js"],"sourcesContent":["/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\nvar re, cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*')\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = ('(?:' + pattern + ')' + after);\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}