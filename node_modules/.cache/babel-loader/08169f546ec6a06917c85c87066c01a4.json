{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar utils = require('./utils');\n\nvar Glob = require('./glob');\n/**\n * Expose `expand`\n */\n\n\nmodule.exports = expand;\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  } // parse the glob pattern into tokens\n\n\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated; // dotfile handling\n\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  } // check for braces with a dotfile pattern\n\n\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  } // if the leading character is a dot or a slash, escape it\n\n\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n  /**\n   * Extended globs\n   */\n  // expand braces, e.g `{1..5}`\n\n\n  glob.track('before braces');\n\n  if (tok.is.braces) {\n    glob.braces();\n  }\n\n  glob.track('after braces'); // expand extglobs, e.g `foo/!(a|b)`\n\n  glob.track('before extglob');\n\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n\n  glob.track('after extglob'); // expand brackets, e.g `[[:alpha:]]`\n\n  glob.track('before brackets');\n\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n\n  glob.track('after brackets'); // special patterns\n\n  glob._replace('[!', '[^');\n\n  glob._replace('(?', '(%~');\n\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n\n  glob._replace('/.', '/(?=.)\\\\.', true); // windows drives\n\n\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true); // negate slashes in exclusion ranges\n\n\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern); // if the pattern has `**`\n\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n\n      glob._replace(/\\*{2,}/g, '**'); // 'foo/*'\n\n\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      } // 'foo/**' or '{**,*}', but not 'foo**'\n\n\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    } // ends with /*\n\n\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true); // ends with *, no slashes\n\n\n    glob._replace(/(?!\\/)\\*$/, star, true); // has 'n*.' (partial wildcard w/ file extension)\n\n\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true); // has '*'\n\n\n    glob._replace('*', oneStar(opts.dot), true);\n\n    glob._replace('?.', '?\\\\.', true);\n\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function (match) {\n      var len = match.length;\n\n      if (len === 1) {\n        return qmark;\n      }\n\n      return qmark + '{' + len + '}';\n    }); // escape '.abc' => '\\\\.abc'\n\n\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1'); // fix '[^\\\\\\\\/]'\n\n\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark); // '///' => '\\/'\n\n\n    glob._replace(/\\/+/g, '\\\\/'); // '\\\\\\\\\\\\' => '\\\\'\n\n\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  } // unescape previously escaped patterns\n\n\n  glob.unescape(glob.pattern);\n\n  glob._replace('__UNESC_STAR__', '*'); // escape dots that follow qmarks\n\n\n  glob._replace('?.', '?\\\\.'); // remove unnecessary slashes in character classes\n\n\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function (match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n\n    return '[^' + inner + ']';\n  });\n}\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n\n  return str;\n}\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\n\n\nvar qmark = '[^/]';\nvar star = qmark + '*?';\nvar nodot = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot = '(?:(?!' + dotfileGlob + ').)*?';\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : nodot + star;\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) {\n    return twoStarDot;\n  }\n\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}","map":{"version":3,"names":["utils","require","Glob","module","exports","expand","pattern","options","TypeError","glob","opts","isGlob","replace","split","join","braces","nobraces","star","tokens","tok","oneStar","dot","parse","is","negated","dotfiles","dotfile","dotdirs","dotdir","test","makeRe","nonegate","charAt","track","extglob","brackets","_replace","nodot","indexOf","negateSlash","globstar","balance","escape","collapse","path","dirname","orig","match","len","length","qmark","unescape","str","ch","res","isFirst","isLast","filter","Boolean","unshift","push","inner","a","b","aarr","alen","blen","dotfileGlob","twoStarDot"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/glob-stream/node_modules/micromatch/lib/expand.js"],"sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar utils = require('./utils');\nvar Glob = require('./glob');\n\n/**\n * Expose `expand`\n */\n\nmodule.exports = expand;\n\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  // parse the glob pattern into tokens\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated;\n\n  // dotfile handling\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  }\n\n  // check for braces with a dotfile pattern\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  }\n\n  // if the leading character is a dot or a slash, escape it\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n\n  /**\n   * Extended globs\n   */\n\n  // expand braces, e.g `{1..5}`\n  glob.track('before braces');\n  if (tok.is.braces) {\n    glob.braces();\n  }\n  glob.track('after braces');\n\n  // expand extglobs, e.g `foo/!(a|b)`\n  glob.track('before extglob');\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n  glob.track('after extglob');\n\n  // expand brackets, e.g `[[:alpha:]]`\n  glob.track('before brackets');\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n  glob.track('after brackets');\n\n  // special patterns\n  glob._replace('[!', '[^');\n  glob._replace('(?', '(%~');\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n  glob._replace('/.', '/(?=.)\\\\.', true);\n\n  // windows drives\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true);\n\n  // negate slashes in exclusion ranges\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern);\n\n    // if the pattern has `**`\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n      glob._replace(/\\*{2,}/g, '**');\n\n      // 'foo/*'\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      }\n\n      // 'foo/**' or '{**,*}', but not 'foo**'\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    }\n\n    // ends with /*\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true);\n    // ends with *, no slashes\n    glob._replace(/(?!\\/)\\*$/, star, true);\n    // has 'n*.' (partial wildcard w/ file extension)\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true);\n    // has '*'\n    glob._replace('*', oneStar(opts.dot), true);\n    glob._replace('?.', '?\\\\.', true);\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function(match) {\n      var len = match.length;\n      if (len === 1) {\n        return qmark;\n      }\n      return qmark + '{' + len + '}';\n    });\n\n    // escape '.abc' => '\\\\.abc'\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1');\n    // fix '[^\\\\\\\\/]'\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark);\n    // '///' => '\\/'\n    glob._replace(/\\/+/g, '\\\\/');\n    // '\\\\\\\\\\\\' => '\\\\'\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  }\n\n  // unescape previously escaped patterns\n  glob.unescape(glob.pattern);\n  glob._replace('__UNESC_STAR__', '*');\n\n  // escape dots that follow qmarks\n  glob._replace('?.', '?\\\\.');\n\n  // remove unnecessary slashes in character classes\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function(match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n    return '[^' + inner + ']';\n  });\n}\n\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n  return str;\n}\n\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\nvar qmark       = '[^/]';\nvar star        = qmark + '*?';\nvar nodot       = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles    = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';\n\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) { return twoStarDot; }\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}