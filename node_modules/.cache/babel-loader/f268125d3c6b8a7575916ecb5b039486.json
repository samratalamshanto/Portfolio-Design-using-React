{"ast":null,"code":"//filter will reemit the data if cb(err,pass) pass is truthy\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\nvar Stream = require('stream').Stream; //create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\n\nmodule.exports = function (mapper, opts) {\n  var stream = new Stream(),\n      self = this,\n      inputs = 0,\n      outputs = 0,\n      ended = false,\n      paused = false,\n      destroyed = false,\n      lastWritten = 0,\n      inNext = false;\n  this.opts = opts || {};\n  var errorEventName = this.opts.failures ? 'failure' : 'error'; // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n\n  var writeQueue = {};\n  stream.writable = true;\n  stream.readable = true;\n\n  function queueData(data, number) {\n    var nextToWrite = lastWritten + 1;\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data]);\n      }\n\n      lastWritten++;\n      nextToWrite++;\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data;\n    } // If the next value is in the queue, write it\n\n\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite];\n      delete writeQueue[nextToWrite];\n      return queueData(dataToWrite, nextToWrite);\n    }\n\n    outputs++;\n\n    if (inputs === outputs) {\n      if (paused) paused = false, stream.emit('drain'); //written all the incoming events\n\n      if (ended) end();\n    }\n  }\n\n  function next(err, data, number) {\n    if (destroyed) return;\n    inNext = true;\n\n    if (!err || self.opts.failures) {\n      queueData(data, number);\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [errorEventName, err]);\n    }\n\n    inNext = false;\n  } // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n\n\n  function wrappedMapper(input, number, callback) {\n    return mapper.call(null, input, function (err, data) {\n      callback(err, data, number);\n    });\n  }\n\n  stream.write = function (data) {\n    if (ended) throw new Error('map stream is not writable');\n    inNext = false;\n    inputs++;\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next);\n      paused = written === false;\n      return !paused;\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if (inNext) throw err;\n      next(err);\n      return !paused;\n    }\n  };\n\n  function end(data) {\n    //if end was called with args, write it, \n    ended = true; //write will emit 'end' if ended is true\n\n    stream.writable = false;\n\n    if (data !== undefined) {\n      return queueData(data, inputs);\n    } else if (inputs == outputs) {\n      //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy();\n    }\n  }\n\n  stream.end = function (data) {\n    if (ended) return;\n    end(data);\n  };\n\n  stream.destroy = function () {\n    ended = destroyed = true;\n    stream.writable = stream.readable = paused = false;\n    process.nextTick(function () {\n      stream.emit('close');\n    });\n  };\n\n  stream.pause = function () {\n    paused = true;\n  };\n\n  stream.resume = function () {\n    paused = false;\n  };\n\n  return stream;\n};","map":{"version":3,"names":["Stream","require","module","exports","mapper","opts","stream","self","inputs","outputs","ended","paused","destroyed","lastWritten","inNext","errorEventName","failures","writeQueue","writable","readable","queueData","data","number","nextToWrite","undefined","emit","apply","hasOwnProperty","dataToWrite","end","next","err","wrappedMapper","input","callback","call","write","Error","written","destroy","process","nextTick","pause","resume"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/map-stream/index.js"],"sourcesContent":["//filter will reemit the data if cb(err,pass) pass is truthy\n\n// reduce is more tricky\n// maybe we want to group the reductions or emit progress updates occasionally\n// the most basic reduce just emits one 'data' event after it has recieved 'end'\n\n\nvar Stream = require('stream').Stream\n\n\n//create an event stream and apply function to each .write\n//emitting each response as data\n//unless it's an empty callback\n\nmodule.exports = function (mapper, opts) {\n\n  var stream = new Stream()\n    , self = this\n    , inputs = 0\n    , outputs = 0\n    , ended = false\n    , paused = false\n    , destroyed = false\n    , lastWritten = 0\n    , inNext = false\n\n  this.opts = opts || {};\n  var errorEventName = this.opts.failures ? 'failure' : 'error';\n\n  // Items that are not ready to be written yet (because they would come out of\n  // order) get stuck in a queue for later.\n  var writeQueue = {}\n\n  stream.writable = true\n  stream.readable = true\n\n  function queueData (data, number) {\n    var nextToWrite = lastWritten + 1\n\n    if (number === nextToWrite) {\n      // If it's next, and its not undefined write it\n      if (data !== undefined) {\n        stream.emit.apply(stream, ['data', data])\n      }\n      lastWritten ++\n      nextToWrite ++\n    } else {\n      // Otherwise queue it for later.\n      writeQueue[number] = data\n    }\n\n    // If the next value is in the queue, write it\n    if (writeQueue.hasOwnProperty(nextToWrite)) {\n      var dataToWrite = writeQueue[nextToWrite]\n      delete writeQueue[nextToWrite]\n      return queueData(dataToWrite, nextToWrite)\n    }\n\n    outputs ++\n    if(inputs === outputs) {\n      if(paused) paused = false, stream.emit('drain') //written all the incoming events\n      if(ended) end()\n    }\n  }\n\n  function next (err, data, number) {\n    if(destroyed) return\n    inNext = true\n\n    if (!err || self.opts.failures) {\n      queueData(data, number)\n    }\n\n    if (err) {\n      stream.emit.apply(stream, [ errorEventName, err ]);\n    }\n\n    inNext = false;\n  }\n\n  // Wrap the mapper function by calling its callback with the order number of\n  // the item in the stream.\n  function wrappedMapper (input, number, callback) {\n    return mapper.call(null, input, function(err, data){\n      callback(err, data, number)\n    })\n  }\n\n  stream.write = function (data) {\n    if(ended) throw new Error('map stream is not writable')\n    inNext = false\n    inputs ++\n\n    try {\n      //catch sync errors and handle them like async errors\n      var written = wrappedMapper(data, inputs, next)\n      paused = (written === false)\n      return !paused\n    } catch (err) {\n      //if the callback has been called syncronously, and the error\n      //has occured in an listener, throw it again.\n      if(inNext)\n        throw err\n      next(err)\n      return !paused\n    }\n  }\n\n  function end (data) {\n    //if end was called with args, write it, \n    ended = true //write will emit 'end' if ended is true\n    stream.writable = false\n    if(data !== undefined) {\n      return queueData(data, inputs)\n    } else if (inputs == outputs) { //wait for processing \n      stream.readable = false, stream.emit('end'), stream.destroy() \n    }\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    end(data)\n  }\n\n  stream.destroy = function () {\n    ended = destroyed = true\n    stream.writable = stream.readable = paused = false\n    process.nextTick(function () {\n      stream.emit('close')\n    })\n  }\n  stream.pause = function () {\n    paused = true\n  }\n\n  stream.resume = function () {\n    paused = false\n  }\n\n  return stream\n}\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}