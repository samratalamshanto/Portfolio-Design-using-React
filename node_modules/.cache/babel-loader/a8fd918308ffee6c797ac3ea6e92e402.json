{"ast":null,"code":"'use strict';\n\nvar through2 = require('through2');\n\nvar Combine = require('ordered-read-streams');\n\nvar unique = require('unique-stream');\n\nvar glob = require('glob');\n\nvar micromatch = require('micromatch');\n\nvar resolveGlob = require('to-absolute-glob');\n\nvar globParent = require('glob-parent');\n\nvar path = require('path');\n\nvar extend = require('extend');\n\nvar sepRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/;\nvar gs = {\n  // Creates a stream for a single glob or filter\n  createStream: function (ourGlob, negatives, opt) {\n    var ourOpt = extend({}, opt);\n    delete ourOpt.root; // Extract base path from glob\n\n    var basePath = ourOpt.base || getBasePath(ourGlob, opt); // Remove path relativity to make globs make sense\n\n    ourGlob = resolveGlob(ourGlob, opt); // Create globbing stuff\n\n    var globber = new glob.Glob(ourGlob, ourOpt); // Create stream and map events from globber to it\n\n    var stream = through2.obj(opt, negatives.length ? filterNegatives : undefined);\n    var found = false;\n    globber.on('error', stream.emit.bind(stream, 'error'));\n    globber.once('end', function () {\n      if (opt.allowEmpty !== true && !found && globIsSingular(globber)) {\n        stream.emit('error', new Error('File not found with singular glob: ' + ourGlob));\n      }\n\n      stream.end();\n    });\n    globber.on('match', function (filename) {\n      found = true;\n      stream.write({\n        cwd: opt.cwd,\n        base: basePath,\n        path: path.normalize(filename)\n      });\n    });\n    return stream;\n\n    function filterNegatives(filename, enc, cb) {\n      var matcha = isMatch.bind(null, filename);\n\n      if (negatives.every(matcha)) {\n        cb(null, filename); // Pass\n      } else {\n        cb(); // Ignore\n      }\n    }\n  },\n  // Creates a stream for multiple globs or filters\n  create: function (globs, opt) {\n    if (!opt) {\n      opt = {};\n    }\n\n    if (typeof opt.cwd !== 'string') {\n      opt.cwd = process.cwd();\n    }\n\n    if (typeof opt.dot !== 'boolean') {\n      opt.dot = false;\n    }\n\n    if (typeof opt.silent !== 'boolean') {\n      opt.silent = true;\n    }\n\n    if (typeof opt.nonull !== 'boolean') {\n      opt.nonull = false;\n    }\n\n    if (typeof opt.cwdbase !== 'boolean') {\n      opt.cwdbase = false;\n    }\n\n    if (opt.cwdbase) {\n      opt.base = opt.cwd;\n    } // Only one glob no need to aggregate\n\n\n    if (!Array.isArray(globs)) {\n      globs = [globs];\n    }\n\n    var positives = [];\n    var negatives = [];\n    var ourOpt = extend({}, opt);\n    delete ourOpt.root;\n    globs.forEach(function (glob, index) {\n      if (typeof glob !== 'string' && !(glob instanceof RegExp)) {\n        throw new Error('Invalid glob at index ' + index);\n      }\n\n      var globArray = isNegative(glob) ? negatives : positives; // Create Minimatch instances for negative glob patterns\n\n      if (globArray === negatives && typeof glob === 'string') {\n        var ourGlob = resolveGlob(glob, opt);\n        glob = micromatch.matcher(ourGlob, ourOpt);\n      }\n\n      globArray.push({\n        index: index,\n        glob: glob\n      });\n    });\n\n    if (positives.length === 0) {\n      throw new Error('Missing positive glob');\n    } // Only one positive glob no need to aggregate\n\n\n    if (positives.length === 1) {\n      return streamFromPositive(positives[0]);\n    } // Create all individual streams\n\n\n    var streams = positives.map(streamFromPositive); // Then just pipe them to a single unique stream and return it\n\n    var aggregate = new Combine(streams);\n    var uniqueStream = unique('path');\n    var returnStream = aggregate.pipe(uniqueStream);\n    aggregate.on('error', function (err) {\n      returnStream.emit('error', err);\n    });\n    return returnStream;\n\n    function streamFromPositive(positive) {\n      var negativeGlobs = negatives.filter(indexGreaterThan(positive.index)).map(toGlob);\n      return gs.createStream(positive.glob, negativeGlobs, opt);\n    }\n  }\n};\n\nfunction isMatch(file, matcher) {\n  if (typeof matcher === 'function') {\n    return matcher(file.path);\n  }\n\n  if (matcher instanceof RegExp) {\n    return matcher.test(file.path);\n  }\n}\n\nfunction isNegative(pattern) {\n  if (typeof pattern === 'string') {\n    return pattern[0] === '!';\n  }\n\n  if (pattern instanceof RegExp) {\n    return true;\n  }\n}\n\nfunction indexGreaterThan(index) {\n  return function (obj) {\n    return obj.index > index;\n  };\n}\n\nfunction toGlob(obj) {\n  return obj.glob;\n}\n\nfunction globIsSingular(glob) {\n  var globSet = glob.minimatch.set;\n\n  if (globSet.length !== 1) {\n    return false;\n  }\n\n  return globSet[0].every(function isString(value) {\n    return typeof value === 'string';\n  });\n}\n\nfunction getBasePath(ourGlob, opt) {\n  var basePath;\n  var parent = globParent(ourGlob);\n\n  if (parent === '/' && opt && opt.root) {\n    basePath = path.normalize(opt.root);\n  } else {\n    basePath = resolveGlob(parent, opt);\n  }\n\n  if (!sepRe.test(basePath.charAt(basePath.length - 1))) {\n    basePath += path.sep;\n  }\n\n  return basePath;\n}\n\nmodule.exports = gs;","map":{"version":3,"names":["through2","require","Combine","unique","glob","micromatch","resolveGlob","globParent","path","extend","sepRe","process","platform","gs","createStream","ourGlob","negatives","opt","ourOpt","root","basePath","base","getBasePath","globber","Glob","stream","obj","length","filterNegatives","undefined","found","on","emit","bind","once","allowEmpty","globIsSingular","Error","end","filename","write","cwd","normalize","enc","cb","matcha","isMatch","every","create","globs","dot","silent","nonull","cwdbase","Array","isArray","positives","forEach","index","RegExp","globArray","isNegative","matcher","push","streamFromPositive","streams","map","aggregate","uniqueStream","returnStream","pipe","err","positive","negativeGlobs","filter","indexGreaterThan","toGlob","file","test","pattern","globSet","minimatch","set","isString","value","parent","charAt","sep","module","exports"],"sources":["G:/anaconda/project/download files/last down/New folder/desktop/Samrat/protfolio/protfolio/node_modules/glob-stream/index.js"],"sourcesContent":["'use strict';\n\nvar through2 = require('through2');\nvar Combine = require('ordered-read-streams');\nvar unique = require('unique-stream');\n\nvar glob = require('glob');\nvar micromatch = require('micromatch');\nvar resolveGlob = require('to-absolute-glob');\nvar globParent = require('glob-parent');\nvar path = require('path');\nvar extend = require('extend');\nvar sepRe = (process.platform === 'win32' ? /[\\/\\\\]/ : /\\/+/);\n\nvar gs = {\n  // Creates a stream for a single glob or filter\n  createStream: function(ourGlob, negatives, opt) {\n\n    var ourOpt = extend({}, opt);\n    delete ourOpt.root;\n\n    // Extract base path from glob\n    var basePath = ourOpt.base || getBasePath(ourGlob, opt);\n\n    // Remove path relativity to make globs make sense\n    ourGlob = resolveGlob(ourGlob, opt);\n\n    // Create globbing stuff\n    var globber = new glob.Glob(ourGlob, ourOpt);\n\n    // Create stream and map events from globber to it\n    var stream = through2.obj(opt,\n      negatives.length ? filterNegatives : undefined);\n\n    var found = false;\n\n    globber.on('error', stream.emit.bind(stream, 'error'));\n    globber.once('end', function() {\n      if (opt.allowEmpty !== true && !found && globIsSingular(globber)) {\n        stream.emit('error',\n          new Error('File not found with singular glob: ' + ourGlob));\n      }\n\n      stream.end();\n    });\n    globber.on('match', function(filename) {\n      found = true;\n\n      stream.write({\n        cwd: opt.cwd,\n        base: basePath,\n        path: path.normalize(filename),\n      });\n    });\n\n    return stream;\n\n    function filterNegatives(filename, enc, cb) {\n      var matcha = isMatch.bind(null, filename);\n      if (negatives.every(matcha)) {\n        cb(null, filename); // Pass\n      } else {\n        cb(); // Ignore\n      }\n    }\n  },\n\n  // Creates a stream for multiple globs or filters\n  create: function(globs, opt) {\n    if (!opt) {\n      opt = {};\n    }\n    if (typeof opt.cwd !== 'string') {\n      opt.cwd = process.cwd();\n    }\n    if (typeof opt.dot !== 'boolean') {\n      opt.dot = false;\n    }\n    if (typeof opt.silent !== 'boolean') {\n      opt.silent = true;\n    }\n    if (typeof opt.nonull !== 'boolean') {\n      opt.nonull = false;\n    }\n    if (typeof opt.cwdbase !== 'boolean') {\n      opt.cwdbase = false;\n    }\n    if (opt.cwdbase) {\n      opt.base = opt.cwd;\n    }\n\n    // Only one glob no need to aggregate\n    if (!Array.isArray(globs)) {\n      globs = [globs];\n    }\n\n    var positives = [];\n    var negatives = [];\n\n    var ourOpt = extend({}, opt);\n    delete ourOpt.root;\n\n    globs.forEach(function(glob, index) {\n      if (typeof glob !== 'string' && !(glob instanceof RegExp)) {\n        throw new Error('Invalid glob at index ' + index);\n      }\n\n      var globArray = isNegative(glob) ? negatives : positives;\n\n      // Create Minimatch instances for negative glob patterns\n      if (globArray === negatives && typeof glob === 'string') {\n        var ourGlob = resolveGlob(glob, opt);\n        glob = micromatch.matcher(ourGlob, ourOpt);\n      }\n\n      globArray.push({\n        index: index,\n        glob: glob,\n      });\n    });\n\n    if (positives.length === 0) {\n      throw new Error('Missing positive glob');\n    }\n\n    // Only one positive glob no need to aggregate\n    if (positives.length === 1) {\n      return streamFromPositive(positives[0]);\n    }\n\n    // Create all individual streams\n    var streams = positives.map(streamFromPositive);\n\n    // Then just pipe them to a single unique stream and return it\n    var aggregate = new Combine(streams);\n    var uniqueStream = unique('path');\n    var returnStream = aggregate.pipe(uniqueStream);\n\n    aggregate.on('error', function(err) {\n      returnStream.emit('error', err);\n    });\n\n    return returnStream;\n\n    function streamFromPositive(positive) {\n      var negativeGlobs = negatives.filter(indexGreaterThan(positive.index))\n        .map(toGlob);\n      return gs.createStream(positive.glob, negativeGlobs, opt);\n    }\n  },\n};\n\nfunction isMatch(file, matcher) {\n  if (typeof matcher === 'function') {\n    return matcher(file.path);\n  }\n  if (matcher instanceof RegExp) {\n    return matcher.test(file.path);\n  }\n}\n\nfunction isNegative(pattern) {\n  if (typeof pattern === 'string') {\n    return pattern[0] === '!';\n  }\n  if (pattern instanceof RegExp) {\n    return true;\n  }\n}\n\nfunction indexGreaterThan(index) {\n  return function(obj) {\n    return obj.index > index;\n  };\n}\n\nfunction toGlob(obj) {\n  return obj.glob;\n}\n\nfunction globIsSingular(glob) {\n  var globSet = glob.minimatch.set;\n\n  if (globSet.length !== 1) {\n    return false;\n  }\n\n  return globSet[0].every(function isString(value) {\n    return typeof value === 'string';\n  });\n}\n\nfunction getBasePath(ourGlob, opt) {\n  var basePath;\n  var parent = globParent(ourGlob);\n\n  if (parent === '/' && opt && opt.root) {\n    basePath = path.normalize(opt.root);\n  } else {\n    basePath = resolveGlob(parent, opt);\n  }\n\n  if (!sepRe.test(basePath.charAt(basePath.length - 1))) {\n    basePath += path.sep;\n  }\n  return basePath;\n}\n\nmodule.exports = gs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}